01.
절차적 프로그래밍(Procedural programming) :
서브 프로그램, 함수 등으로 불리는 프로시저를 기본 단위로 하는 프로그래밍이다.
행위의 추상화와 코드의 재사용이라는 목적을 프로시저를 통해 달성한다는 특징이 있다.
Procedural이라는 단어는 프로시저를 기반으로 한다는 의미에서 붙은 것이기 때문에,
본래의 의미는 절차적 프로그래밍보다는 프로시저 기반 프로그래밍에 더 가깝지만,
해당 단어가 '절차적'으로 직역되어 알려지며 절차적 프로그래밍으로 불리게 되었고,
이후 등장한 객체지향 프로그래밍과 대비되면서, 일부에서 절차지향 프로그래밍이라는
왜곡된 명칭으로 사용되고 있다.

객체지향 프로그래밍(Object-oriented programming) :
프로그램을 단순히 명령어의 집합으로 해석하는 것이 아닌, 현실의 대상을 추상화한
개념인 객체를 기본 단위로 하여, 객체간의 상호 작용으로 해석하는 프로그래밍이다.
추상화, 캡슐화, 상속, 다형성이라는 4가지 요소를 기본 요소로 하고 있으며,
코드를 직관적으로 이해하기 쉽고, 변화에 유연하여 유지와 보수가 간편하며,
독립성과 신뢰성이 높은 객체의 경우 재사용성이 높다는 장점이 있기 때문에
오늘날의 많은 프로그래밍 언어에서 채택하고 있는 프로그래밍 패러다임이다.
하지만 객체지향 프로그래밍은, 기능의 여러 부분에서 컴퓨터 친화적이지 않은 구현을
하도록 강제하기 때문에, 멤버 함수 호출, 가상 함수 호출 등에서 발생하는 오버헤드,
캐시 미스, 메모리 단편화 등의 문제로 절차적 프로그래밍에 비해 다소 성능상의
불리한 면을 가지고 있다.

02.
복사 초기화 : =
직접 초기화 : ()
균일 초기화 : {}

03.
malloc(Memory Allocation) :
단순히 지정한 바이트 만큼의 메모리 공간을 할당하여 반환하는 함수.
공간의 크기 지정이 필요하며, 초기화가 불가능하다.

new :
지정한 자료형에 대해 지정한 수만큼의 메모리 공간을 할당하여 반환하는 예약어.
공간의 크기 지정이 불필요하며, 초기화가 가능하다.

04.
오버로딩(Overloading) :
같은 이름, 다른 인자 목록의 함수에 대해 다른 정의를 할 수 있는 기능.

05.
오버라이딩(Overriding) :
기본 클래스의 (순수) 가상 함수에 대해 파생 클래스에서 다른 정의를 할 수 있는 기능.
파생 클래스에서 오버라이드 시 override 키워드를 적용하여 명시적 오버라이드가 가능하다.

06.
추상 클래스(abstract class) :
abstract 키워드를 적용했거나, 1개 이상의 순수 가상 함수를 가진 클래스.
클래스 선언 뒤에 abstract를 적용하여 추상 클래스 선언이 가능하다.
순수 가상 함수 보유 시, 해당 함수의 구현을 강제하기 위해,
abstract 적용 시, 해당 클래스의 상속을 강제하기 위해 사용한다.

인터페이스(interface) :
__interface 키워드를 사용하여 정의 가능.
열거체 정의, 멤버 함수 선언 등의 제한적인 정의만이 가능하며,
멤버 함수 선언의 경우, 자동으로 순수 가상 함수로 지정되고
상속과 모든 멤버에 대해 접근 제어가 public으로 강제된다.
개념 자체가 상속을 전제로 하고 있으며, 정보의 제공을 제한하여
정보 은닉을 실현하고, 접근 방식을 제한함으로써 다수의 파생 개체를
공통의 접근 방식을 통해 제어하도록 하기 위한 목적으로 사용한다.

07.
얕은 복사(Shallow Copy) :
멤버 변수의 값에 대해 일대일로 진행하는 단순 복사.

깊은 복사(Deep Copy) :
참조 형식 등의 멤버 변수에 대해 방식을 정의한 복사.

참조 형식 등에 대한 복사의 경우, 참조 대상의 실제 값에 대한 복사가 필요하기 때문에
해당 유형의 멤버 변수 복사가 필요할 시 복사 생성자 및 대입 연산자의 재정의가 필요하다.

08.
const_cast :
const 키워드에 대한 캐스팅을 수행한다.

static_cast :
논리적으로 변환 가능한 타입간의 안전한 캐스팅을 수행한다.

dynamic_cast :
가상 함수를 가진 클래스의 인스턴스 포인터에 대해 업/다운 캐스팅을 수행한다.

reinterpret_cast :
다른 타입의 포인터간 캐스팅과 정수/포인터간 캐스팅을 수행한다.

09.
함수 템플릿의 경우 호출하는 파일에서 템플릿의 정의에 따라 함수 인스턴스를 생성하는데,
헤더에 선언만이 존재할 경우, 정의를 찾을 수 없기 때문에 인스턴스를 생성할 수가 없다.

10.
int const :
리턴하는 값의 int형 변환 불가

* const :
리턴하는 값의 포인터형 변환 불가

(const int i)
받는 매개변수 i의 변환 불가

DoSomething() const :
멤버 변수의 값 변환 불가

11.
constexpr(Constant expression) :
const 개체와 다르게 실행 시간이 아닌 컴파일 시간에 할당되는 특성을 가진다.
매크로와 유사한 면이 있으나, 디버깅 시 추적이 가능하다는 부분에서 차이를 보이며,
상수에 이름을 붙인다는 본연의 의미에 있어 더욱 부합한다고 할 수 있다.

12.
static_assert :
constexpr과 유사하게, assert는 런타임에 기능하여 프로그램을 중단시키는 반면,
static_assert는 컴파일 시간에 기능하여 주어진 수식이 false일 시 오류를 발생시킨다.
때문에 당연하게도 static_assert에 주어지는 수식은 컴파일 시간에 값이 결정되는
수식이어야 하며, 주로 constexpr과 더불어 템플릿 메타 프로그래밍에 자주 활용된다.

13
기본 인자(Default Parameter) :
호출에 대해 기본 값이 지정된 매개변수.
인자 목록의 끝에서부터 지정한다는 규칙이 있으며,
기본 인자에 대해서는 인자 전달의 생략이 가능하다.
선언과 정의 중 하나에 대해서만 지정이 가능하며,
선언에 대해 지정하는 것이 일반적이다.
오버로드와 함께 사용할 경우 호출의 모호성 문제를
유발할 수 있으므로 사용에 유의가 필요하다.

14
다형성(Polymorphism) :
하나의 공통 형식을 통해 다양한 기능을 수행할 수 있는 성질.

가상 함수 테이블(Virtual function table, vtable) :
가상 함수를 가진 클래스와 해당 클래스의 파생 클래스가 가상 함수 구현을 위해
가지는 함수 포인터 배열로서, 선언된 가상 함수의 수만큼의 원소를 가진다.
파생 클래스에서 오버라이드 하지 않는다면 기본 클래스의 함수 포인터를,
오버라이드 할 경우 오버라이드 된 파생 클래스의 함수 포인터를 갖는다.


15.
변환 생성자(Conversion constructor) :
임의의 자료형 하나를 인자로 하는 생성자.
해당 클래스의 인스턴스를 인자로 하는 함수에 대해,
인스턴스가 아닌, 지정된 자료형의 값을 전달하여
의도하지 않은 호출이 가능하다는 문제가 있다.
생성자 앞에 explicit 키워드를 적용하여 직접 초기화 시에만
인스턴스 생성이 가능하도록 하면 해당 문제를 해결할 수 있다.

16.
문제에서 묻는 개념이 일반적으로 정형화되어 있는 개념이 아닌,
주관적인 판단 기준에서 출제되었으므로 출제자의 기준을 따른다.

Object Relationship

- Composition(구성) : part-of    내 뇌는 나에 속한 것이라서 나를 없애면 뇌도 사라진다. 
- Aggregation(집합) : has-a      내 자동차는 내 것이지만 내가 사라진다고 해서 자동차가 사라지진 않는다.
- Association(연계) : uses-a     장기간 치료를 받을 경우 의사도 환자를 알아야 하고, 환자도 의사를 알아야 한다.
                                 서로가 서로에게 영향을 끼질 수 있다. (좋지 않은 경우, 하나 바뀌면 둘 다 수정될 수 있기 때문 <커플링 관계>)
- Dependency (의존) : depends-on 환자와 목발의 경우, 상태가 좋아지면 목발이 필요없다. (좋은 경우)
- Inheritance(상속) : is-a       같다.

관계 형태                                               다른 클래스에 속할수 있는가  멤버의 존재를 클래스가 관리  방향성
Composition(구성)     part-of         전체/부품                   No                           Yes            단방향
Aggregation(집합)     has-a           전체/부품                   Yes                          No             단방향
Association(연계)     uses-a          용도 외엔 무관              Yes                          No             단방향 or 양방향
Dependency (의존)     depends-on      용도 외엔 무관              Yes                          Yes            단방향

17.
* 전치 증가 연산자(Prefix increment operator)
Number & operator ++()
{
    ++value;

    return *this;
}

또는

Number & operator ++()
{
    return *this = Number(++value);
}

* 후치 증가 연산자(Postfix increment operator) :
증가 이전의 복사본을 전달해야 하기 때문에 대상 인스턴스의 참조를 반환하지 않는다.

Number const operator ++(int)
{
    return Number(value++);
}

* 타입 캐스트 연산자 - int *(Type casting operator to cast to int *)
operator int *()
{
    return &value;
}

18.
실행 결과 :
constructor
copy_constructor
copy_constructor

이유 :
인스턴스 생성 시의 복사 초기화는 암시적으로 복사 생성자를 호출한다.

19.
좌측 값 참조(L-Value Reference) :
일반적인 변수, 클래스의 인스턴스 등에 대한 참조.

우측 값 참조(R-Value Reference) :
대입, 반환 등을 위해 일시적으로 생성하는 임시 개체에 대한 참조.
해당 참조를 이용해, 복사와 대입에 대해 불필요한 연산을 생략한
Move Semantics의 구현이 가능하며, 전달된 인자를 우측 값 참조로 반환하는
std::move 함수를 사용하면 좌측 값을 우측 값 참조로 캐스트할 수 있다.

20.
1. 기본 생성자
	- 객체를 생성할 때 입력받는 인자가 없을경우 호출되는 생성자
	- MyClass();

2. 복사 생성자
	- 객체를 생성할 때 자신과 같은 타입의 클래스 객체를 L-Value Reference로 받을경우 호출되는 생성자
	- MyClass(const MyClass& other);

3. 이동 생성자
	- 객체를 생성할 때 자신과 같은 타입의 클래스 객체를 R-Value Reference로 받을경우 호출되는 생성자
	- MyClass(MyClass&& other) noexcept;

4. 복사 대입 연산자
	- 자신과 같은 타입의 클래스 객체를 L-Value Reference로 대입 받을 때 호출되는 연산자 
	- MyClass& operator=(const MyClass& other);

5. 이동 대입 연산자
	- 자신과 같은 타입의 클래스 객체를 R-Value Reference로 대입 받을 때 호출되는 연산자 
	- MyClass& operator=(MyClass&& other) noexcept;

6. 소멸자
﻿	- 객체가 소멸될 때 호출되는 소멸자
	- ~MyClass();

21.
같은 기본 클래스를 가지는 두 파생 클래스를 한 클래스가 상속할 때 생기는 문제로,
두 클래스의 공통된 멤버들을 모두 상속하며 호출의 모호성을 발생시키는 문제이다.
해결 방법으로는 가급적 이러한 상속을 피하는 방법과, 이런 상속 형태가 꼭 필요한 경우,
기본 클래스 지정 시 virtual 키워드를 적용하여 가상 상속을 하는 방법이 있다.

22.
반환 값 최적화(Return Value Optimization, RVO) :
값 반환 시, 임시 개체를 생성하지 않도록 하는 최적화 기법.
특정 자료형의 생성자를 반환할 경우, 임시 개체를 생성하지 않고
반환 값을 대상에 직접 대입하는 최적화를 의미한다.
별도의 최적화 설정을 하지 않아도 자동으로 동작하며,
확장된 개념으로 NRVO가 존재한다.

명명 반환 값 최적화(Named Return Value Optimization, NRVO) :
생성자 반환에 대한 최적화인 RVO에서 확장하여 생성자가 아닌,
이미 생성한 개체를 반환하는 경우에도 임시 개체를 생성하지 않고
반환하는 개체의 값을 대상에 직접 대입하는 최적화를 의미한다.
해당 기능의 동작을 위해서는 별도의 최적화 설정을 필요로 한다.

23.
컨테이너(Container) :
임의의 자료형을 저장할 수 있게 설계된 같은 자료형 개체의 집합.
언어 수준에서 지원하는 배열 또한 컨테이너의 일종이며,
STL의 array, list, queue, deque, vector, map 등이 대표적이다.

반복자(Iterator) :
각 컨테이너의 효율적인 순회와 탐색을 위한 개체로, 그 종류와 동작 방식은
컨테이너의 종류에 따라 달라질 수 있다.

24.
파생 클래스가 상속받는 기반 클래스의 소멸자가 가상함수가 아니기 때문에 
파생 클래스가 업캐스팅된 상태로 소멸시, 자신의 소멸자가 호출되지않아 
문제가 발생할 수 있다. 그렇기 때문에 상속될 가능성이 있는 클래스의 소멸자는
 virtual 키워드를 필수적으로 적용시켜야 한다.

25.
유효하지 않은 인덱스의 원소 접근에 대해 -1을 반환할 경우,
유효 인덱스의 반환 값 -1에 대해서도 신뢰성이 떨어지게 되고,
이에 따라, 값으로 -1을 사용할 수 없게 되는 등의 문제가 발생할 수 있다.
assert를 사용한 프로그램 중단 등의 방법으로 문제를 해결할 수 있다. 